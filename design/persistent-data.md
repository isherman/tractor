# Persistent Data

## Motivation

We need a way to manage persistent data generated by the robot and its related software. Examples of persistent data include debug logs, calibration data, and configuration data.

We'd like to manage persistent data in a way that is consistent, forwards/backward-compatible, and portable: so that a subset of the data may be shared externally, or the data may be periodically backed up to a centralized location, and remain useful.

Protocol buffers and standardized file formats (e.g. `png`) provide consistency and forward/backward-compatibility. The notion of a _Resource Archive_ provides portability.

## Resource Archives

A resource archive is a hierarchical collection of persistent data.

Examples of resource archives include a `.tar` file, an S3 bucket, or an on-robot datastore.

An atom of persistent data is a _Resource_.

See the [Resource](https://github.com/farm-ng/tractor/blob/master/protos/farm_ng_proto/tractor/v1/resource.proto) proto definition for more details.

## Blobstore

For a resource archive on the robot, we designate a directory on the filesystem as a _Blobstore_ and provide utilities to help standardize storage and retrieval of Resources.

The blobstore could be implemented with a database (and still can be in the future), but using the filesystem directly is appealing for a couple of reasons:

- We're mainly concerned with storing non-relational blobs, some of them large.
- It allows the user to easily browse and edit the "database".

Depending on how things evolve, we may re-evalute the use of an object storage engine like [Minio](https://min.io/) or a (relational | non-relational | key-value store) database.

Some important conventions:

- The blobstore is immutable. A core service, `blobstore-supervisor`, ensures that new files are [enforced immutable by the filesystem](https://linux.die.net/man/1/chattr).

- `blobstore-supervisor` also logs changes to the blobstore and notifies the Eventbus on events of interest, such as the addition of a new configuration file.

- The blobstore location is determined by the environment variable `BLOBSTORE_ROOT`.

- The blobstore write API provides affordances for avoiding key collision, for example, by automatically attaching a suffix to paths that would collide.

- The blobstore maintains a list of top-level directories, or "buckets", specified in a protobuf definition. Examples include:

```protobuf
// Resource Archive root-level directories
enum Bucket {
  BUCKET_UNSPECIFIED = 0;
  BUCKET_LOGS = 1;
  BUCKET_CALIBRATION_DATASETS = 2;
  BUCKET_APRILTAG_RIG_MODELS = 3;
  BUCKET_BASE_TO_CAMERA_MODELS = 4;
  BUCKET_CONFIGURATIONS = 5;
}
```

- The blobstore stores data on the filesystem with conventions that make it easy for users and programs to browse, such as:

  - Store each blob as its own file
  - Choose standard file extensions that make the data interpretable by file browsers and the like (e.g. `image/png` stored as `.png`)

- An example API to the Blobstore looks like:

```cpp
// Writes a blob of bytes to the blobstore location specified by `resource`.
//
// `resource.path` must be a valid blobstore-relative path.
// Specifically, its first path segment must be a valid bucket name.
//
// **NOTE** The returned `resource.path` may be different than the provided `resource.path`, in the case of
// collision with an existing resource.
//
// Throws an exception on invalid path or unsuccessful write.
Resource WriteBlob(Resource resource, const std::vector<std::byte>& bytes)

// Returns the blob at the location specified by `resource`
//
// `resource.path` must be a valid blobstore-relative path.
// Specifically, its first path segment must be a valid bucket name.
//
// Throws an exception on unsuccessful read (e.g. resource does not exist).
std::vector<std::byte> ReadBlob(Resource resource)

// A convenience wrapper around WriteBlob, for protobufs.
//
// `resource.content_type` must be a valid content type for the provided protobuf.
// Throws an exception if `proto` cannot be serialized to `resource.content_type`.
Resource WriteProtobuf(Resource resource, ProtoT proto)

// A convenience wrapper around ReadBlob, for protobufs.
//
// Throws an exception if resource cannot be deserialized.
ProtoT ReadProtobuf(Resource resource)
```

- Software components should avoid accessing the filesystem directly. For example, OpenCV code should `imencode` to a `std::vector<std::byte>` and `Blobstore::WriteBlob` rather than accessing the file system directly with `imwrite`.

## Robot Logs

A standard log is a resource archive, in the form of a `.tar` file, that includes a log of IPC traffic as well as any resources referenced in the IPC log.

The structure of the `.tar` file looks like:

```bash
$ tar --list --file cal01.tar
logs/cal01/
logs/cal01/tracking_camera_left_apriltag-02505-00007.png
logs/cal01/tracking_camera_left_apriltag-02505-00001.png
logs/cal01/reprojection/
logs/cal01/reprojection/00003-02807-00014.png
logs/cal01/reprojection/00004-02807-00004.png
logs/cal01/reprojection/00004-02807-00015.png
logs/cal01/reprojection/00009-02807-00009.png
logs/cal01/tracking_camera_left_apriltag-02505-00005.png
logs/cal01/tracking_camera_left_apriltag-02505-00002.png
logs/cal01/tracking_camera_left_apriltag-02505-00003.png
logs/cal01/tracking_camera_left_apriltag-02505-00000.png
logs/cal01/tracking_camera_left_apriltag-02505-00008.png
logs/cal01/tracking_camera_left_apriltag-02505-00004.png
logs/cal01/apriltag_rig_model/
logs/cal01/apriltag_rig_model/solved-02807-00021.json
logs/cal01/apriltag_rig_model/initial-02807-00010.json
logs/cal01/events-02498-00000.log
```

A log can be packaged up from the blobstore with a command like:

```bash
$ cd $BLOBSTORE_ROOT
$ tar --create --verbose --file cal01.tar logs/cal01
```

## ArchiveManager

The `ArchiveManager` coordinates multiple processes that may want to write to the blobstore in a coordinated fashion -- for example, a camera driver process writing images to `logs/experiment01/00001.png` while an IPC logger process writes to `logs/experiment01/ipc.log`.

The API looks something like:

```cpp

// TODO

```

## Configuration

Configuration is an important category of persistent data. For our purposes configuration is just a group of Resources.

- Robot configuration should be specified as Resources in the `CONFIGURATIONS` bucket of the blobstore.

- Separate configuration resrouces may be used for different subsystems of the robot (e.g. kinematics, camera).

- The blobstore should provide an API to fetch the latest configuration. Internally, this will likely rely on which configuration file has the latest modified time, or the latest `ISO8601` date in its filename (since the blobstore is immutable).

- Software components that rely on configuration should load the latest configuration from the blobstore upon start. Software components that can dynamically update when robot configuration changes should subscribe to `configuration/new` on the EventBus (published by the `blobstore-supervisor`).

- Configuration shouldn't reference other resources, even if this results in some denormalization.

- Configuration updates can be performed manually. Configuration is saved in a human-readable format. A human can copy/paste the configuration, with edits, to a new file with a later ISO8601 timestamp.

- Configuration updates can also be performed by invoking the `update-configuration` program in the frontend.
